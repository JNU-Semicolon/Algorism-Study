### [문제 분석]
# 목적 : 각 회의가 겹치지 않도록 n개의 회의실을 사용하는 회의 개수의 최댓값 구하기
# -> 빨리 끝나는 회의 순서대로 정렬 하여 회의 개수 늘리기
# -> 끝나는 시간이 같다면 빠른 시작 순으로 정렬하기
# !주의 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 
# 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

### [문제 풀이]
# 1단계 : 회의의 수(n)와, 각 회의의 시작, 끝 시간을 입력 받는다.
# 2단계 : 시작하는 시간이 빠른 순서대로 오름차순 정렬을 한다.
# 3단계 : 끝나는 시간이 빠른 순서대로 오름차순 정렬을 한다. 
# (이미 시작하는 시간 오름차순으로 정렬된 상태기 때문에 끝나는 시간이 같을 때에도 시작시간의 오름차순으로 정렬되어 있다.)
# 4단계 : 회의 개수를 출력한다.

# 회의의 수(n)와, time 리스트 선언하기
n = int(input())
times = []

# 각 회의의 시작, 끝 시간을 입력 받기
for i in range(n):
    start, end = map(int, input().split())
    times.append([start, end])
    
# 시작하는 시간이 빠른 순서대로 오름차순 정렬
times.sort(key = lambda x: x[0])
# 끝나는 시간이 빠른 순서대로 오름차순 정렬
times.sort(key = lambda x: x[1])

cnt = 1

# 다음 회의 시작시간이 현재 회의 끝나는 시간보다 크거나 같을 경우 cnt +1 해준다.
# for i in range(1, n):
#     if times[i][0] >= times[i-1][1]:
#         cnt += 1
# ???

# end 초기값 설정
endTime = times[0][1]

# 다음 회의 시작시간이 현재 회의 끝나는 시간보다 크거나 같을 경우 cnt +1 해준다.
# 크거나 같을 때 갱신이 되고, 만약 if문이 충족되지 않을 시, endtime이 갱신되지 않는다.
for i in range(1, n):
    if times[i][0] >= endTime:
        cnt += 1
        endTime = times[i][1]
        
print(cnt)


